import { isString } from '@aws-lambda-powertools/commons/typeutils';
export class SizedItem {
    value;
    logLevel;
    byteSize;
    constructor(value, logLevel) {
        if (!isString(value)) {
            throw new Error('Value should be a string');
        }
        this.value = value;
        this.logLevel = logLevel;
        this.byteSize = Buffer.byteLength(value);
    }
}
export class SizedSet extends Set {
    currentBytesSize = 0;
    hasEvictedLog = false;
    add(item) {
        this.currentBytesSize += item.byteSize;
        super.add(item);
        return this;
    }
    delete(item) {
        const wasDeleted = super.delete(item);
        if (wasDeleted) {
            this.currentBytesSize -= item.byteSize;
        }
        return wasDeleted;
    }
    clear() {
        super.clear();
        this.currentBytesSize = 0;
    }
    shift() {
        const firstElement = this.values().next().value;
        if (firstElement) {
            this.delete(firstElement);
        }
        return firstElement;
    }
}
export class CircularMap extends Map {
    #maxBytesSize;
    #onBufferOverflow;
    constructor({ maxBytesSize, onBufferOverflow, }) {
        super();
        this.#maxBytesSize = maxBytesSize;
        this.#onBufferOverflow = onBufferOverflow;
    }
    setItem(key, value, logLevel) {
        const item = new SizedItem(value, logLevel);
        if (item.byteSize > this.#maxBytesSize) {
            throw new Error('Item too big');
        }
        const buffer = this.get(key) || new SizedSet();
        if (buffer.currentBytesSize + item.byteSize >= this.#maxBytesSize) {
            this.#deleteFromBufferUntilSizeIsLessThanMax(buffer, item);
            if (this.#onBufferOverflow) {
                this.#onBufferOverflow();
            }
        }
        buffer.add(item);
        super.set(key, buffer);
        return this;
    }
    #deleteFromBufferUntilSizeIsLessThanMax = (buffer, item) => {
        while (buffer.currentBytesSize + item.byteSize >= this.#maxBytesSize) {
            buffer.shift();
            buffer.hasEvictedLog = true;
        }
    };
}
